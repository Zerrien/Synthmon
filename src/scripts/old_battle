var BattleController = {
	"protagonist":null,
	"antagonist":null,
	"proCur":null,
	"antCur":null,
	"type":null,

	"state":null,

	"action":null,
	"enemyAction":null,
	"events":[],
	"connections":{
		"proMonSprite":null,
		"antMonSprite":null
	},
	"getProtagonist":function() {
		return this.protagonist.c("trainer");
	},
	"getAntagonist":function() {
		return this.antagonist.c("trainer");
	},
	"getProCurrent":function() {
		return this.protagonist.c("trainer").synthmon[this.proCur];
	},
	"getAntCurrent":function() {
		return this.antagonist.c("trainer").synthmon[this.antCur];
	},
	"setCurrent":function(_who, _which) {
		console.log(_who)
		if(_who == "antagonist") {
			this.antCur = this.getAntagonist().synthmon.indexOf(_which);
			console.log(this.antCur);
		} else if (_who == "protagonist") {
			this.proCur = this.getProtagonist().synthmon.indexOf(_which);
		} else {
			console.log("???");
		}
	},
	
	"configure":function(_pro, _ant, _type) {
		//Not sure if this belongs in the battle configure.
		battleEntities = [];

		this.protagonist = _pro;
		this.antagonist = _ant;

		this.proCur = 0;
		this.antCur = 0;

		this.state = 0;
		this.type = _type || null;

		//var battleMenu = MenuController.combatMenu.make();
		//battleEntities.push(battleMenu);

		var baseContainer = new gui_Container(canvas.width - 200, 0, 200, 20 + 60 + 60 + 60 + 40 + 20);
		baseContainer.addChild(new gui_Button("Attack", 20, 20, 200 - 40, 40, function() {
			var attackContainer = new gui_Container(canvas.width - 400 - 20, 20, 400, 400);
			attackContainer.addChild(new gui_ButtonArray(BC.getProCurrent().abilities, 20, 20, 360, 360, function() {
				BC.action = {
					"type":"attack",
					"synth":BC.getProCurrent(),
					"target":BC.getAntCurrent(),
					"use":BC.getProCurrent().abilities[this.ref]
				}
				this.parent.parent.parent.removeElement(this.parent.parent);
			}));
			battleScene.gui.addElement(attackContainer, -1);
		}));
		baseContainer.addChild(new gui_Button("Synthmon", 20, 20 + 20 + 40, 200 - 40, 40, function() {
		}));
		baseContainer.addChild(new gui_Button("Items", 20, 20 + 20 + 40 + 20 + 40, 200 - 40, 40, function() {
			var inventoryContainer = new gui_Container(0, 0, 400, 400);
			inventoryContainer.addChild(new gui_List(player.c("inventory").items, 20, 20, 360, 360, function() {
				
				var use = this.itemRef.use.battleuse;
				use.ref = this.itemRef;
				if(use.action == "target_synthmon") {
					var synthContainer = new gui_Container(40, 40, 400, 400);
					battleScene.gui.addElement(synthContainer, -1);
					synthContainer.addChild(new gui_Text("Use " + this.string + " on who?", 200, 20));
					synthContainer.addChild(new gui_PlayerSynthmon(20, 40, 400 - 40, 400 - 60, function() {
						BC.action = {
							"type":"item",
							"item": use.ref,
							"target": this.synthmonRef
						}
					}));
					synthContainer.addChild(new gui_Button("X", 400 - 20, 0, 20, 20, function() {
						battleScene.gui.removeElement(synthContainer);
					}));
				}
				
				//if(this.itemRef.use.worlduse) {
				//	var use = this.itemRef.use.worlduse;
				//	use.ref = this.itemRef;
				//	if(use.action == "target_synthmon") {
				//		var synthContainer = new gui_Container(40, 40, 400, 400);
				//		ECS.Scenes.World.gui.addElement(synthContainer, -1);
				//		synthContainer.addChild(new gui_Text("Use " + this.string + " on who?", 200, 20));
				//		synthContainer.addChild(new gui_PlayerSynthmon(20, 40, 400 - 40, 400 - 60, function() {
				//			switch(use.effect.target) {
				//				case "hp":
				//					if(use.effect.type == "add") {
				//						this.synthmonRef.heal(use.effect.amount);
				//					} else if (use.effect.type == "sub") {
				//						this.synthmonRef.heal(-1 * use.effect.amount);
				//					}
				//					break;
				//				default:
				//					console.warn("Attempting to apply unknown effect target... Debug further.")
				//					break;
				//			}
				//			player.c("inventory").removeItem(use.ref);
				//			ECS.Scenes.World.gui.removeElement(synthContainer);
				//		}));
				//		synthContainer.addChild(new gui_Button("X", 400 - 20, 0, 20, 20, function() {
				//			ECS.Scenes.World.gui.removeElement(synthContainer);
				//		}));
				//	}
				//}
				
			}));
			battleScene.gui.addElement(inventoryContainer, -1);
		}));
		baseContainer.addChild(new gui_Button("Run", 20, 20 + 60 + 60 + 60, 200 - 40, 40, function() {
		}));
		battleScene.gui.addElement(baseContainer, -1);

		
		//var baseContainer = new gui_Container(canvas.width - 200, 0, 200, canvas.height);
		//baseContainer.addChild(new gui_Button("Inventory", 20, 20, 200 - 40, 40, function() {
		//	var inventoryContainer = new gui_Container(0, 0, 400, 400);
		//	inventoryContainer.addChild(new gui_List(player.c("inventory").items, 20, 20, 360, 360));
		//	worldScene.gui.addElement(inventoryContainer, -1);
		//}));
		//baseContainer.addChild(new gui_Button("Team", 20, 20 + 20 + 40, 200 - 40, 40, function() {
		//}));
		//baseContainer.addChild(new gui_Button("Status", 20, 20 + 20 + 40 + 20 + 40, 200 - 40, 40, function() {
		//}));
		//baseContainer.addChild(new gui_Button("Options", 20, 20 + 60 + 60 + 60, 200 - 40, 40, function() {
		//}));
		//baseContainer.addChild(new gui_Button("Back", 20, canvas.height - 20 - 40, 200 - 40, 40, function() {
		//}));
		//worldScene.gui.addElement(baseContainer, -1);
		
		//makeBattleStartEvent(_type);
		
		makeBattleStartEvent(_type);

		//Not sure if this belongs in the battle configure.
		gameState = "Battle";
	},
	
	"firstEvent":function() {
		return this.events[0];	
	},
	"configure":function(_a, _b, _type) {

	}
}



//	Turn logic stuff.
//		What team member
//		What attack


function sendPlayerHome() {
	var playerPos = player.c("worldposition");
	var playerRevive = player.c("revives");

	for(var i = 0; i < player.c("trainer").synthmon.length; i++) {
		player.c("trainer").synthmon[i].curHP = player.c("trainer").synthmon[i].maxHP;
	}

	playerPos.zone = playerRevive.zone;
	playerPos.x = playerRevive.position.x;
	playerPos.y = playerRevive.position.y;

	loadZone(playerRevive.zone);
}
/*
function makeFaintedEvent(_who) {
	var target, targetImg, dir;
	if(_who == "protagonist") {
		target = BC.getProCurrent();
		targetImg = BC.connections.proMonSprite;
		BC.connections.proMonSprite = null;
		dir = -128;
	} else {
		target = BC.getAntCurrent();
		targetImg = BC.connections.antMonSprite;
		BC.connections.antMonSprite = null;
		dir = 128;
	}

	var hasFaintedDialogue = makeUIDialogue(target.name + " has fainted!");
	var faintedEvent = new BattleEvent(1000, null, function() {
		battleEntities.splice(battleEntities.indexOf(targetImg), 1);
	});
	faintedEvent.setVariable(targetImg.c("uiposition"), "x", dir, 1000, false);
	faintedEvent.short(hasFaintedDialogue);
	faintedEvent.queue = true;

	BC.events.push(faintedEvent);
}
*/
function getOwner(_synth) {
	if(BC.getAntCurrent() == _synth) {
		return "antagonist"
	} else if(BC.getProCurrent() == _synth) {
		return "protagonist";
	} else {
		console.error("Neither operator is currently using: " + JSON.stringify(_synth));
		return "NULL";
	}
}
function makeFaintedEvent(_synth) {
	var target, targetImg, dir;
	if(getOwner(_synth) == "protagonist") {
		target = _synth;
		targetImg = BC.connections.proMonSprite;
		BC.connections.proMonSprite = null;
		dir = -128;
	} else {
		target = _synth;
		targetImg = BC.connections.antMonSprite;
		BC.connections.antMonSprite = null;
		dir = 128;
	}

	var hasFaintedDialogue = makeUIDialogue(target.name + " has fainted!");
	var faintedEvent = new BattleEvent(1000, null, function() {
		battleEntities.splice(battleEntities.indexOf(targetImg), 1);
	});
	faintedEvent.setVariable(targetImg.c("uiposition"), "x", dir, 1000, false);
	faintedEvent.short(hasFaintedDialogue);
	faintedEvent.queue = true;

	BC.events.push(faintedEvent);
}
/*
function makeTurnEvent(_side, _action) {
	var from, to, toOwner, enemy;
	if(_side == "protagonist") {
		from = BC.getProCurrent();
		to = BC.getAntCurrent();
		toOwner = BC.getAntagonist();
		enemy = "antagonist";
	} else if (_side == "antagonist") {
		from = BC.getAntCurrent();
		to = BC.getProCurrent();
		toOwner = BC.getProtagonist();
		enemy = "protagonist";
	}

	var dmg = from.getEvalDmg(to, _action);
	makeAttackEvent(_side, _action, dmg);
	if(to.curHP - dmg <= 0) {
		makeFaintedEvent(enemy);
		var remaining = toOwner.hasHealthy(to);
		if(remaining) {
			var chosen = remaining[Math.floor(Math.random() * remaining.length)];
			var sendEvent = sendSynthmonEvent(toOwner, chosen, enemy);
			BC.events.push(sendEvent);
			return "FAINTED";
		} else {
			//game over for this user!
			return "LOSS";
		}
	}
	return "SECOND_TURN";
}
*/
function makeTurnEvent(_action) {
	//TODO FIX tHP THIS IS AWFUL UHG
	if((_action.synth.tHP === undefined || _action.synth.tHP === null) || _action.synth.tHP && _action.synth.tHP > 0) {
		from = _action.synth;
		to = _action.target;

		if(to.tHP === undefined || to.tHP === null) {
			to.tHP = to.curHP;
		}
		if(from.tHP === undefined || from.tHP === null) {
			from.tHP = from.curHP;
		}
		var dmg = from.getEvalDmg(to, _action.use);
		makeAttackEvent(_action, dmg);
		to.tHP -= dmg;
		if(to.tHP <= 0) {
			makeFaintedEvent(to);
		}
	}
}
function evaluateTurn() {
	var pAct = BattleController.action;
	var eAct = BattleController.enemyAction;
	var actions = [BattleController.action, BattleController.enemyAction];
	for(var i = 0; i < actions.length; i++) {
		if(actions[i].type == "item") {
			//Item stuff here.
			actions.splice(i--, 1);
		}
	}
	actions.sort(function(_a, _b) {
		var aSpd = _a.synth.getEvalStat("Speed");
		var bSpd = _b.synth.getEvalStat("Speed");
		if(aSpd > bSpd) {
			return -1;
		} else if (aSpd < bSpd) {
			return 1;
		} else {
			return -1 + Math.floor(Math.random() * 2) * 2;
		}
	});
	for(var i = 0; i < actions.length; i++) {
		var result = makeTurnEvent(actions[i]);
	}
	/*
	if(pAct.type == "attack" && eAct.type == "attack") {
		var pSpd = BC.getProCurrent().getEvalStat("Speed");
		var aSpd = BC.getAntCurrent().getEvalStat("Speed");

		if(pSpd == aSpd) {
			var offset = Math.floor(Math.random() * 2);
			if(offset == 0) {
				pSpd += 1;
			} else {
				pSpd -= 1;
			}
		}
		var secondTurn = true;
		if(pSpd > aSpd) {
			var outcome = makeTurnEvent("protagonist", pAct.use);
			if(outcome == "LOSS") {
				//console.log("Player won!");
				var winningDialog = makeUIDialogue("You won!");
				var winningEvent = new BattleEvent(1000, null, function() {
					gameState = "World";
				});
				winningEvent.short(winningDialog);
				winningEvent.queue = true;
				BC.events.push(winningEvent);
				secondTurn = false;
			} else if (outcome != "SECOND_TURN") {
				secondTurn = false;
			}
		} else {
			//Antagonist's turn.
			var outcome = makeTurnEvent("antagonist", eAct.use);
			if(outcome == "LOSS") {
				var losingDialog = makeUIDialogue("You lost....");
				var losingEvent = new BattleEvent(1000, null, function() {
					sendPlayerHome();
					gameState = "World";
					
				});
				losingEvent.short(losingDialog);
				losingEvent.queue = true;
				BC.events.push(losingEvent);
			} else if (outcome != "SECOND_TURN") {
				secondTurn = false;
			}
		}

		if(secondTurn) {
			if(pSpd > aSpd) {
				var outcome = makeTurnEvent("antagonist", eAct.use);
				if(outcome == "LOSS") {
					var losingDialog = makeUIDialogue("You lost....");
					var losingEvent = new BattleEvent(1000, null, function() {
						sendPlayerHome();
						gameState = "World";
						
					});
					losingEvent.short(losingDialog);
					losingEvent.queue = true;
					BC.events.push(losingEvent);
				}
			} else {
				var outcome = makeTurnEvent("protagonist", pAct.use);
				if(outcome == "LOSS") {
					var winningDialog = makeUIDialogue("You won!");
					var winningEvent = new BattleEvent(1000, null, function() {
						gameState = "World";
					});
					winningEvent.short(winningDialog);
					winningEvent.queue = true;
					BC.events.push(winningEvent);
				}
			}
		}
	}
	*/

	BattleController.action = null;
	BattleController.enemyAction = null;
}

function enemyAction() {
	//Currently picking a random ability.
	//This includes mid-swaps, items, etc.
	BattleController.enemyAction = {
		"type":"attack",
		"synth":BC.getAntCurrent(),
		"target":BC.getProCurrent(),
		"use":BattleController.antagonist.c('trainer').synthmon[0].abilities[Math.floor(Math.random())]
	}
}



//	Make specific events.
//		KO
//		Attacks
//		Sends out Synthmon
//		Ect.


function makeBattleStartEvent() {
	var playerSprite = new ECS.Entity();
	playerSprite.addComponent(new ECS.Components.UIPosition(0, 0));
	playerSprite.addComponent(new ECS.Components.BattleSprite(assets.images.player));

	var enemySprite = new ECS.Entity();
	enemySprite.addComponent(new ECS.Components.UIPosition(128, 0));
	enemySprite.addComponent(new ECS.Components.BattleSprite(assets.images.opponent));

	var shortsBattle = makeUIDialogue("Enemy Trainer wants to battle!!!");
	var firstEvent = new BattleEvent(1000);
	firstEvent.short(shortsBattle);
	firstEvent.toAdd.push(playerSprite);
	firstEvent.toAdd.push(enemySprite);
	firstEvent.queue = true;

	var secondEvent = sendSynthmonEvent(BC.getAntagonist(), BC.getAntCurrent(), "antagonist");
	secondEvent.toRemove.push(enemySprite);
	secondEvent.setVariable(enemySprite.c("uiposition"), "x", 128, 1000, false);


	var thirdEvent = sendSynthmonEvent(BC.getProtagonist(), BC.getProCurrent(), "protagonist");
	thirdEvent.toRemove.push(playerSprite);
	thirdEvent.setVariable(playerSprite.c("uiposition"), "x", -128, 1000, false);

	BC.events.push(firstEvent);
	BC.events.push(secondEvent);
	BC.events.push(thirdEvent);
}

function makeAttackEvent(_action, _dmg) {
	var target, targetImg, abilityImg, dialogueLine;
	target = _action.target;
	targetImg = BC.connections.antMonSprite;
	abilityImg = assets.images.water_attack;
	dialogueLine = _action.synth.name + " used " + _action.use.name + "!";

	var attackDialogue = makeUIDialogue(dialogueLine);
	var dialogueEvent = new BattleEvent(1000);
	dialogueEvent.toAdd.push(attackDialogue);

	var waterAttack = new ECS.Entity();
	waterAttack.addComponent(new ECS.Components.UIPosition(64 + 32,  32));
	waterAttack.addComponent(new ECS.Components.BattleSprite(abilityImg));
	waterAttack.addComponent(new ECS.Components.BattleAnimated(3, 3, 500 / 9));
	var animationEvent = new BattleEvent(500);
	animationEvent.short(waterAttack);

	var damageEvent = new BattleEvent(500, function() {
		targetImg.addComponent(new ECS.Components.BattleShake());
	}, function() {
		targetImg.removeComponent("battleshake");
	});
	damageEvent.setVariable(target, "curHP", -1 * _dmg, 500, false);
	damageEvent.minimum = 0;
	damageEvent.toRemove.push(dialogueEvent);

	BC.events.push(dialogueEvent);
	BC.events.push(animationEvent);
	BC.events.push(damageEvent);
}

/*
function makeFaintedEvent(_who) {
	var target, targetImg, dir;
	if(_who == "protagonist") {
		target = BC.getProCurrent();
		targetImg = BC.connections.proMonSprite;
		BC.connections.proMonSprite = null;
		dir = -128;
	} else {
		target = BC.getAntCurrent();
		targetImg = BC.connections.antMonSprite;
		BC.connections.antMonSprite = null;
		dir = 128;
	}

	var hasFaintedDialogue = makeUIDialogue(target.name + " has fainted!");
	var faintedEvent = new BattleEvent(1000, null, function() {
		battleEntities.splice(battleEntities.indexOf(targetImg), 1);
	});
	faintedEvent.setVariable(targetImg.c("uiposition"), "x", dir, 1000, false);
	faintedEvent.short(hasFaintedDialogue);
	faintedEvent.queue = true;

	BC.events.push(faintedEvent);
}
*/

/*
function makeTurnEvent(_side, _action) {
	var from, to, toOwner, enemy;
	if(_side == "protagonist") {
		from = BC.getProCurrent();
		to = BC.getAntCurrent();
		toOwner = BC.getAntagonist();
		enemy = "antagonist";
	} else if (_side == "antagonist") {
		from = BC.getAntCurrent();
		to = BC.getProCurrent();
		toOwner = BC.getProtagonist();
		enemy = "protagonist";
	}

	var dmg = from.getEvalDmg(to, _action);
	makeAttackEvent(_side, _action, dmg);
	if(to.curHP - dmg <= 0) {
		makeFaintedEvent(enemy);
		var remaining = toOwner.hasHealthy(to);
		if(remaining) {
			var chosen = remaining[Math.floor(Math.random() * remaining.length)];
			var sendEvent = sendSynthmonEvent(toOwner, chosen, enemy);
			BC.events.push(sendEvent);
			return "FAINTED";
		} else {
			//game over for this user!
			return "LOSS";
		}
	}
	return "SECOND_TURN";

}
*/
function sendSynthmonEvent(_who, _what, _side) {
	var monSprite = new ECS.Entity();
	if(_side == "antagonist") {
		monSprite.addComponent(new ECS.Components.UIPosition(128, 0));
		monSprite.addComponent(new ECS.Components.BattleSprite(assets.images.piggen_front));
		BC.connections.antMonSprite = monSprite;
	} else if (_side == "protagonist") {
		monSprite.addComponent(new ECS.Components.UIPosition(0, 0));
		monSprite.addComponent(new ECS.Components.BattleSprite(assets.images.piggen_back));
		BC.connections.proMonSprite = monSprite;
	}

	var dialogue = "";
	if(_side == "protagonist" && BC.protagonist == player) {
		dialogue = "Go! " + _what.name + "!";
	} else {
		dialogue = _who.tName + " sends out " + _what.name + "!";
	}

	var sendMon = makeUIDialogue(dialogue);
	var sendEvent = new BattleEvent(1000, function() {
		BC.setCurrent(_side, _what);
	});
	sendEvent.toAdd.push(monSprite);
	sendEvent.short(sendMon);
	sendEvent.queue = true;
	return sendEvent;
}

//
//	Helper functions
//

//1) Uses old UI Component code
//2) Should be an assemblage.
function makeUIDialogue(_string) {
	var dialogue = new ECS.Entity();
	dialogue.addComponent(new ECS.Components.UIPosition(64, 0));
	dialogue.addComponent(new ECS.Components.UIDialogueBox(_string));
	return dialogue;
}
